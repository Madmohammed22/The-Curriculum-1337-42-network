    /* At this part we are creating a socket, and checking if an
    error may accure, if it does we must incounter return value
    of an correct creating a socket is -1. */

    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket < 0)
        return perror("opening stream socket."), EXIT_FAILURE;

    /* We define so set of info related to the socket like wich family
    is used when it comes to the versin of IPs
    and port by using htons that transform an unsigned machine
    byte order to network byte order. as well as sin_addr which define
    we can work and listen with all the available IPs */

    sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_port = htons(8080);
    serverAddress.sin_addr.s_addr = INADDR_ANY;
    int len = sizeof(serverAddress);
    /* bind() is used to bind a socket to a specific address and port,
    making the socket listen for incoming connection requests on that address and port */

    if (bind(serverSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0)
        return perror("binding stream socket."), EXIT_FAILURE;

    /* Find out assigned port and print it out with the help of getsockname function*/
    if (getsockname(serverSocket, (struct sockaddr *)&serverAddress, (socklen_t *)&len) == -1)
        return perror("getting socket name."), EXIT_FAILURE;
    std::cout << "Socket port " << ntohs(serverAddress.sin_port) << std::endl;

    /* The listen() function applies only to stream sockets. It indicates a readiness to accept
    client connection requests, and creates a connection request queue of length
    backlog to queue incoming connection requests */
    /* Start accepting connections. */
    if (listen(serverSocket, 5) < 0)
        return perror("listen stream socket"), EXIT_FAILURE;


To get extra information about running multiple media content in your web server, you can search for the following topics:

Serving Static Files in Web Servers: This will give you an overview of how to configure your web server to serve different types of files like HTML, CSS, JavaScript, images, videos, etc.
MIME Types Configuration: Learn about configuring the correct MIME types for different file extensions to ensure they are handled properly by the browser.
C++ Web Server Examples: Look for examples and tutorials on how to implement a web server in C++, which often include handling various media types.
HTTP Response Headers: Understand the different HTTP response headers, especially Content-Type, and how to set them based on the file type.
Asynchronous File Serving: Learn about asynchronous or non-blocking I/O operations to efficiently serve multiple media files simultaneously.
File Streaming in C++: Find information on how to stream large files (like videos) in chunks to avoid loading the entire file into memory.
These search terms should help you find detailed guides, examples, and best practices for serving multiple types of media content from your web server.

Suggested Search Queries:
"Serving static files in C++ web server"
"MIME types configuration for web server"
"C++ web server handling HTML CSS MP4"
"HTTP response headers for media files"
"Asynchronous file serving in C++"
"Streaming large files in C++ web server"
These queries should provide you with a good amount of information to enhance your web server's capabilities.

    //*/
   /*
    do
    {
        msgsocket = accept(serverSocket, (struct sockaddr *)&clientAddress, &clientLen);
        if (msgsocket < 0)
            return perror("accept stream socket"), delete server,  EXIT_FAILURE;
        else
        {
            do
            {

                memset(buffer, 0, sizeof(buffer));
                rval = recv(msgsocket, buffer, sizeof(buffer), 0);
                if (rval == 0)
                    std::cout << "Ending connections" << std::endl;
                else
                {
                    std::string request(buffer);
                    std::string filePath = server->parsRequest(request);
                    std::string content = readFile(filePath);
                    if (content.empty())
                    {
                        std::string new_path = "/var/www/Errors/404/" + server->parsRequest404(request);
                        std::ifstream file(new_path.c_str());
                        if (!file.is_open())
                            return  perror(NULL), delete server, EXIT_FAILURE;

                        std::string contentType = server->getContentType(new_path);
                        std::string notFound = server->creatHttpResponseForPage404(contentType, file);
                        send(msgsocket, notFound.c_str(), notFound.length(), 0);
                    }
                    else
                    {
                        std::string contentType = server->getContentType(filePath);
                        std::string httpResponse = server->creatHttpResponse(contentType, content);
                        send(msgsocket, httpResponse.c_str(), httpResponse.length(), 0);
                    }
                }
            } while (rval > 0);
            close(msgsocket);
        }
    } while (true);
    */